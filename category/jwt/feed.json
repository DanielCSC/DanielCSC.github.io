{
    "version": "https://jsonfeed.org/version/1",
    "title": "云雾散尽 我爱你人尽皆知 • All posts by \"jwt\" category",
    "description": "人生海海  山山而川  不过尔尔",
    "home_page_url": "https://github.com/DanielCSC/DanielCSC.github.io.git",
    "items": [
        {
            "id": "https://github.com/DanielCSC/DanielCSC.github.io.git/2020/11/12/JWT/",
            "url": "https://github.com/DanielCSC/DanielCSC.github.io.git/2020/11/12/JWT/",
            "title": "JWT--JSON WEB TOKEN",
            "date_published": "2020-11-12T11:39:37.000Z",
            "content_html": "<h1 id=\"json-web-token\"><a class=\"markdownIt-Anchor\" href=\"#json-web-token\">#</a> Json Web Token</h1>\n<h3 id=\"什么是jwt\"><a class=\"markdownIt-Anchor\" href=\"#什么是jwt\">#</a> 什么是 JWT</h3>\n<blockquote>\n<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准 (RFC 7519). 该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。</p>\n</blockquote>\n<ul>\n<li>说起 JWT，我们应该来谈一谈基于 token 的认证和传统的 session 认证的区别。</li>\n</ul>\n<h3 id=\"传统的session认证\"><a class=\"markdownIt-Anchor\" href=\"#传统的session认证\">#</a> 传统的 session 认证</h3>\n<p>我们知道，http 协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据 http 协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为 cookie, 以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，这就是传统的基于 session 认证。</p>\n<p>但是这种基于 session 的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于 session 认证应用的问题就会暴露出来.</p>\n<h3 id=\"基于session认证所显露的问题\"><a class=\"markdownIt-Anchor\" href=\"#基于session认证所显露的问题\">#</a> 基于 session 认证所显露的问题</h3>\n<p><strong>Session</strong>: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言 session 都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p>\n<p><strong>扩展性</strong>：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p>\n<p><strong>CSRF</strong>: 因为是基于 cookie 来进行用户识别的，cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>\n<h3 id=\"jwt与session的差异\"><a class=\"markdownIt-Anchor\" href=\"#jwt与session的差异\">#</a> JWT 与 Session 的差异</h3>\n<ul>\n<li>\n<p>相同点是，它们都是存储用户信息；然而，Session 是在服务器端的，而 JWT 是在客户端的。</p>\n</li>\n<li>\n<p>Session 方式存储用户信息的最大问题在于要占用大量服务器内存，增加服务器的开销。而 JWT 方式将用户状态分散到了客户端中，可以明显减轻服务端的内存压力。</p>\n</li>\n<li>\n<p>Session 的状态是存储在服务器端，客户端只有 session id；而 Token 的状态是存储在客户端。</p>\n</li>\n</ul>\n<h3 id=\"基于token的鉴权机制\"><a class=\"markdownIt-Anchor\" href=\"#基于token的鉴权机制\">#</a> 基于 token 的鉴权机制</h3>\n<p>基于 token 的鉴权机制类似于 http 协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于 token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>\n<p>流程上是这样的：</p>\n<ul>\n<li>用户使用用户名密码来请求服务器</li>\n<li>服务器进行验证用户的信息</li>\n<li>服务器通过验证发送给用户一个 token</li>\n<li>客户端存储 token，并在每次请求时附送上这个 token 值</li>\n<li>服务端验证 token 值，并返回数据</li>\n</ul>\n<h3 id=\"jwt长什么样\"><a class=\"markdownIt-Anchor\" href=\"#jwt长什么样\">#</a> JWT 长什么样</h3>\n<p>JWT 是由三段信息构成的，将这三段信息文本用 <code>.</code>  链接一起就构成了 Jwt 字符串</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<span class=\"token punctuation\">.</span>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ<span class=\"token punctuation\">.</span>cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ</pre></td></tr></table></figure><h3 id=\"jwt的构成\"><a class=\"markdownIt-Anchor\" href=\"#jwt的构成\">#</a> JWT 的构成</h3>\n<ul>\n<li>\n<p>第一部分我们称它为头部（header)</p>\n</li>\n<li>\n<p>第二部分我们称其为载荷（payload)</p>\n</li>\n<li>\n<p>第三部分是签证（signature)</p>\n</li>\n</ul>\n<h4 id=\"头部header\"><a class=\"markdownIt-Anchor\" href=\"#头部header\">#</a> 头部（header）</h4>\n<p>jwt 的头部承载两部分信息：</p>\n<ul>\n<li>声明类型，这里是 jwt</li>\n<li>声明加密的算法 通常直接使用 HMAC SHA256</li>\n</ul>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token string\">'typ'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'JWT'</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token string\">'alg'</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'HS256'</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>然后进行 base64 加密（该加密是可以对称解密的), 构成了第一部分.</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</pre></td></tr></table></figure><h4 id=\"载荷playload\"><a class=\"markdownIt-Anchor\" href=\"#载荷playload\">#</a> 载荷（playload）</h4>\n<p>载荷就是存放有效信息的地方，这些有效信息包含三个部分</p>\n<ul>\n<li>标准中注册的声明</li>\n<li>公共的声明</li>\n<li>私有的声明</li>\n</ul>\n<h5 id=\"标准中注册的声明-建议但不强制使用\"><a class=\"markdownIt-Anchor\" href=\"#标准中注册的声明-建议但不强制使用\">#</a> <strong>标准中注册的声明</strong> (建议但不强制使用) :</h5>\n<p><strong>iss</strong>: jwt 签发者</p>\n<p><strong>sub</strong>: jwt 所面向的用户</p>\n<p><strong>aud</strong>: 接收 jwt 的一方</p>\n<p><strong>exp</strong>: jwt 的过期时间，这个过期时间必须要大于签发时间</p>\n<p><strong>nbf</strong>: 定义在什么时间之前，该 jwt 都是不可用的.</p>\n<p><strong>iat</strong>: jwt 的签发时间</p>\n<p><strong>jti</strong>: jwt 的唯一身份标识，主要用来作为一次性 token, 从而回避重放攻击。</p>\n<h5 id=\"公共的声明\"><a class=\"markdownIt-Anchor\" href=\"#公共的声明\">#</a> 公共的声明：</h5>\n<p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。但不建议添加 <code>敏感信息</code> ，因为该部分在客户端可解密.</p>\n<h5 id=\"私有的声明\"><a class=\"markdownIt-Anchor\" href=\"#私有的声明\">#</a> <strong>私有的声明</strong> ：</h5>\n<p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token string\">\"sub\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"1234567890\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"John Doe\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token string\">\"iat\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">1516239022</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>然后进行 base64 加密，得到 Jwt 的第二部分</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</pre></td></tr></table></figure><h4 id=\"签证signature\"><a class=\"markdownIt-Anchor\" href=\"#签证signature\">#</a> 签证（signature）</h4>\n<p>jwt 的第三部分是一个签证信息，这个签证信息由三部分组成：</p>\n<ul>\n<li>header (base64 后的)</li>\n<li>payload (base64 后的)</li>\n<li>secret</li>\n</ul>\n<p>这个部分需要 base64 加密后的 header 和 base64 加密后的 payload 使用 <code>.</code>  连接组成的字符串，然后通过 header 中声明的加密方式进行加盐 <code>secret</code>  组合加密，然后就构成了 jwt 的第三部分。</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>HMACSHA256<span class=\"token punctuation\">(</span>base64UrlEncode<span class=\"token punctuation\">(</span>header<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\".\"</span> <span class=\"token operator\">+</span> base64UrlEncode<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">,</span>secret<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>将这三部分用 <code>.</code>  连接成一个完整的字符串，构成了最终的 jwt:</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<span class=\"token punctuation\">.</span>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ<span class=\"token punctuation\">.</span>cThIIoDvwdueQB468K5xDc5633seEFoqwxjF_xSJyQQ</pre></td></tr></table></figure><p><code>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</code></p>\n<h3 id=\"下列场景中使用json-web-token是很有用的\"><a class=\"markdownIt-Anchor\" href=\"#下列场景中使用json-web-token是很有用的\">#</a> 下列场景中使用 JSON Web Token 是很有用的：</h3>\n<ul>\n<li>Authorization (授权) : 这是使用 JWT 的最常见场景。一旦用户登录，后续每个请求都将包含 JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是现在广泛使用的 JWT 的一个特性，因为它的开销很小，并且可以轻松地跨域使用。</li>\n<li>Information Exchange (信息交换) : 对于安全的在各方之间传输信息而言，JSON Web Tokens 无疑是一种很好的方式。因为 JWT 可以被签名，例如，用公钥 / 私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改。</li>\n</ul>\n<h3 id=\"jwt与oauth20的区别\"><a class=\"markdownIt-Anchor\" href=\"#jwt与oauth20的区别\">#</a> JWT 与 OAuth2.0 的区别</h3>\n<ul>\n<li>OAuth2.0 是一种授权框架 ，JWT 是一种认证协议</li>\n<li>无论使用哪种方式切记用 HTTPS 来保证数据的安全性</li>\n<li>OAuth2.0 用在使用第三方账号登录的情况 (比如使用 weibo, qq, github 登录某个 app)，而 JWT 是用在前后端分离，需要简单的对后台 API 进行保护时使用。</li>\n</ul>\n<h3 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h3>\n<h4 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h4>\n<ul>\n<li>因为 json 的通用性，所以 JWT 是可以进行跨语言支持的，像 Python,Java,JavaScript,PHP 等很多语言都可以使用。</li>\n<li>因为有了 payload 部分，所以 JWT 可以在自身存储一些其他业务逻辑所必要的非敏感信息。</li>\n<li>便于传输，jwt 的构成非常简单，字节占用很小，所以它是非常便于传输的。</li>\n<li>它不需要在服务端保存会话信息，所以它易于应用的扩展</li>\n</ul>\n<h4 id=\"安全相关\"><a class=\"markdownIt-Anchor\" href=\"#安全相关\">#</a> 安全相关</h4>\n<ul>\n<li>不应该在 jwt 的 payload 部分存放敏感信息，因为该部分是客户端可解密的部分。</li>\n<li>保护好 secret 私钥，该私钥非常重要。</li>\n</ul>\n",
            "tags": [
                "jwt"
            ]
        }
    ]
}